from rouge import Rouge

reference = "So regardless, you're going to have to download the code from GitHub. Again, I will leave that description, download that, open up the folder and kind of we could start working from there. Now really what I'm going to be showing you here mostly is sprite sheet animation, pixel perfect collision using what's called masks, and then how you can do the scrolling background generating objects, all of that kind of stuff. Now obviously we're going to write the code from scratch, but you can either work off that existing code or you can kind of clear the file and type along with me, whatever you want to do. We're not going to use most of this, but I wanted to include all of it so that you could kind of continue the game later if you want. For main characters, we have a bunch of sprite sheets inside of here and I'll show you how we can split these sprite sheets apart and use all of the different kind of animations inside of your right. Now the reason I'm doing all this OS stuff is because we are going to be dynamically loading all of the sprite sheets and the images so we don't have to manually like type out the file names that we want. I'll show you how we write a function that just loads these folders here, kind of splits the sprite sheets automatically and gives us all of the images that we're interested in. So I'm going to say PI game, dot display, dot set underscore mode, and I'm going to pass the width and the height to this window argument here, this mode argument. So I need to make a function here and I'm going to call this get underscore background. This function is going to return to me a list that contains all of the background tiles that we need to draw. Now, the reason I'm saying that right now is because the way I'm going to load this image relies on the fact that you're running this code from the directory that it exists in. Okay, so I'm going to load my image and the image is equal to py game dot image, dot load. So now that I have the width in the height, I'm going to say tiles is equal to an empty list and then I'm going to loop through essentially how many tiles I need to create in the X and the Y direction. So what I'll be doing is continually moving the positions based on how this for loop is going, right? I'm also going to return the image so that I can know what image I need to use when I'm drawing all of these tiles. And for the name I'm going to reference here in the background folder any of these images so we can use anyone we want. And now I want to set up something that's going to draw my background. And then I'm going to say window doublets and actually I need to take my BG image as well. So let's take that and I'm going to draw the background image. And then what I need to pass here is the position I want to draw it at, which is going to be tile. So in case anyone's confused, what we're doing here is looping through every single tile that we have, and then we're going to draw our background image at that position, which will fill the entire screen with background images. Then what we're going to do is update the display, the reason we update it so that every single frame we kind of clear the screen. Styling the entire screen looks pretty good to me and we can quite easily change this if we want by just going here and saying okay, rather than blue, I want yellow. So we'll start by just creating like a block for our player, kind of move the block around, have a jumping around. And the reason for that is that it makes it very easy to do pixel perfect collision when we have two sprite objects which we're going to have because we're inheriting from the pie game sprite class, we can use a method that tells us if the sprites are colliding with each other. You don't have to understand exactly what the Sprite is, but it kind of denotes that we have some properties on our class and then it allows these special paging methods to use those properties to handle the collision for us so we don't have to write anything too complicated when it comes to the collision, although we still do need to handle it a bit. Okay, so what we're going to do here is define our initialization area, taking a self, an x, y, width and height. But for now, since we're going to have like a block for our player, and so we add that image, we're going to have a width and height. Now what I'm going to do is say self-doubt racked is equal to pi game dot rect and then pass my x y width and height. And this is going to make it a little bit easier for us to kind of move the player around and do collision and all of that. And this is going to take in the velocity you want to move in the left direction and the next is going to be moving in the right direction. And then to move to the right, we're going to say self that exfil is equal to VEL. Now the reason we use negative velocity here is because if we want to go left, we have to subtract from our exposition in PI game. And I'm going to say self-taught animation count is equal to zero. Now, we're not going to use these right now, but I just want to add them in for now at least, and you'll see why in a second. Now, I'm also going to say up here, self-taught direction is equal to left. And the reason we're doing that is so that the animation doesn't look all wonky when we go from going left to right, we need to kind of reset the count that we're using to change the animation frames. And this is going to move our character in the correct direction and handle things like updating the animation and all of the stuff that we constantly need to do for our character. So now if we call loop and we have some velocity in the X direction is going to move our character to the left or to the right. Okay, so I will move the player in 1/2, but for now, let's just see if this is working, if it's going to show up on the screen. So I'm going to say key is equal to pi game dark keys actually not key squeaks get underscore pressed. And then I'm going to say if this is the case, then player dots move underscore left and how much do I want to move the player likes we have to pass the velocity. We essentially set the velocity to zero and then if we are moving left or right, so for pressing these keys, then we change the velocity to be, you know, the negative player velocity or the positive player velocity based on the direction we're moving in. All right now I need to make sure before I do this that I call my loop function okay and I pass my ops. And the reason I need to call loop is because loop is what actually moves my player, right? Okay, so I'm going to hit my right key. Now gravity is a little bit complicated because we want to have like kind of a realistic gravity, right, that actually implement some basic physics. So for this, I'm going to make a variable in my player class because it's the only place we need it right now, I'm going to say is equal to one. The point of this is that if I want this value to be in seconds, then I need to take whatever my count is, which I'm going to increment every single loop. She now this sheet has six different animations or six different frames which represent what this guy is going to look like while he's kind of jumping or double jumping in the air. Now notice here with these images that they're in different directions or let's say they're all kind of facing, right? Okay, so let's do this first thing I will do actually, is I'll write the function that will flip our image. I think sheets is fine and what this is going to do is load all of the different sprite sheets for our characters. I also want to take in the desired width and height of my image and if we need to load multiple directions so I'm going to say direction equals false is the default parameters so that we only load like the left and the right side images like we flip the images if you passed this equal to true. Okay, now the first thing we need to do is determine the path to the images we're going to be loading. Now the way I do that, as often as the images is equal to and this is going to be f for F in list directory again notice I can use that. We're going to pass py game dot s c which allows us to load again transparent images. But this just what we need to load these images and now we need to create a rectangle which is going to tell us where in this image, an image being the sprite sheet that we want to take, an individual image from and bullet it onto the surface. So I'm going to say rectangle is equal to PI game dot rect. Okay, so now we need to say if direction, then all underscore sprites and this is going to be image dot replace, it's going to be dot PG, it's going to be an empty string plus underscore, right is equal to our sprites. So for falling, for hit, for idle, we need a left and a right side. So we're going to say, okay, all sprites at and then we're just going to strip off the dot page from whatever the name of our base image was that's going to give us run, jump, idle, hit whatever the name of our files and then we're going to spend on her school right or underscore left now for underscore right, that's our basic sprites for underscore left. Now that we've load our sprite sheet, we actually want to start using this. So I'm going to say my sprites is equal to and it's going to be load spreadsheets and now I need to pass what I want to load. So I'm accessing the key from my dictionary and then I'm going to access the first frame of this key, which is zero because every single key is a whole sprite, right? And then if we want, we can just turn off the gravity for right now so we can kind of see it on the screen and it doesn't just disappear. So the issue here is that since we load a directional sprite, we need to reference either idle right or idle left. So now it'll change based on if we're going left or right. So now I'm going to say if my self-taught x velocity does not equal zero, then my sprite sheet is going to be equal to run. Okay, now that we have that, what we're going to do is say the sprite that we could be using for this animation is equal to self dot sprites and this is in all capitals at the sprite sheet name. Now that we've done that, we need to essentially iterate through these sprites and every few seconds change the sprite that we're showing so that it looks like we're animating. So we need to add a variable here that is going to account for the amount of delay between changing sprites. Now I'm going to come here and I'm going to say that my Sprite index, which essentially is Sprite that I want to be using here, is equal to my self dot animation count, which we're going to increment the second integer divided by my self-taught animation delay modulus by the length of the sprites that I'm using. Now what we can do is remove this here from draw and we just need to now call the self dot update sprite from our loop. So it's different like kind of sizes to the sprites, right? Again, I know this seems a bit weird, but we're going to do this are going to say self direct is equal to self dot and then it's going to be sprite get underscore rect. And we're going to say that the top left of this rectangle is equal to the self direct dot x and these self-correct dot y. So I'm going to go here and say self-deport update and now we're done with most of what we need for the player. So what we want to do now is we want to start adding blocks onto the screen and then letting a player fall, collide with those blocks and then be able to jump. That rectangle is equal to py game dots rect and then this is going to be x, y, width and height. We're going to say self-taught image is equal to py game dot surface and then this is going to be width height and then we're going to say py game dot source alpha like that if we spell py game correctly. We're not actually going to instantiate this, but this just defines all of the properties that we need for a valid sprite. Now we're going to say define init around second self, x, y and the size of our block. Then we're going to say block is equal to load block, which is going be a function that we write in a second that will take a size. When we write it, we're going to hit the block at position zero zero and then we're going to say the self dump mask is equal to py game don't masked from surface we're going to take our self that image and there you go we have our mask which we need for collision. We also could just say self that image is equal to the block, but let's do it this way for now. Okay, so let's now write our get block function, which I'm going to do beneath our get sprite sheet or load spreadsheets. So 96 zero is my position and then I want to load the size of this, which I think is going to be either 96 or 64 or something along those lines. And if yeah, I was going to say we can load different one, but I don't want to waste time guessing which one it is. Okay, so we've passed what size we want our block to be. Now I understand again, Spike, if using this size is going to be the dimension of this block, so you want to pass whatever the size from this sprite sheet is that you want to get. That's what you're going to change when you want to load a different image for your block. So for our block, let's just put it kind of randomly on the screen for now where do I want to put this? Let's go with something like actually, I'm going to create a variable first, say block size. Let's put this at zero height minus the block underscore size. So I'm going to pass blocks to my draw function. Then for my blocks, let's actually just replace this and instead we'll just pass for okay, what I've done here with this for loop is I've said I want to create blocks that go kind of to the left and to the right of the screen. So I don't want to just fill the current screen because we're going to have scrolling background in the second, which will implement in a minute. Anyways, I want to have some kind of go into the left and some going to the right. So inside of Handle Move is where we're going to handle our collision, which means we need to have a list of objects that we can potentially be colliding with. For now, we'll just start with vertical orientation player objects and the displacement in why that we just moved now we're going to have collided underscore is equal to a list I'm going to say for object in objects. I'm going to say if my game dot sprites, dot collide mask and then we're going to pass our player and our object. Otherwise I'm going to say if my display so y is less than zero and I suppose this can be an elf, then what I will do is say my player direct top is equal to the object rect bottom because if I'm moving up, which means I have a negative velocity, then I am hitting the bottom of an object. So we're going to say self dot fall count is equal to zero. Now we're going to say our self, that jump count is equal to zero. If we hit our head, I want to reverse our velocity so that now we move down because we're moving up, right? So I'm going to multiply my velocity by negative ones that when I hit my head, I kind of bounce off the block and go downwards. Okay, so that's all we need for right now, for hitting the head. I can say define jump self and when we jump all we're going to do is say self doubt y underscore velocity is equal to the negative of self dog gravity multiplied by whatever factor you want in terms of the speed of your jump. I'm going to say if the self-taught jump underscore count is equal to one, this means that I'm double jumping. Because for the second jump I want you to have to time it based on like when you're jumping, right? Now what I'll do now is add like falling and jumping animations because obviously it looks kind of weird right now when I'm jumping, but there you go. I thought, I mean to say if not self if self doubt y underscore velocity does not equal zero, then what I will do is say if self-taught jump count equals equals one, then I'm going to say my sprite sheet is equal to jump. So You can see that what happens is when I hit the block, when I collide with it, it's going to reset my gravity count and then I'm going to kind of spawn to the top of the block. And you can see that what actually happened is when I jump and I get to the peak of my jump, you can see that it starts the falling state because right now my velocity is change directions. Okay, so now we have jumping, now we have running around and colliding with blocks then quite a bit actually. Then we will do our horizontal collision and then we will pretty much be done after I add kind of that like fire state, right? But what this involves is having some offset X, which I'm going to say is equal to zero now the way that I want to have it and I'll just illustrate here, is that when I'm on the screen, I only start scrolling the background when I get close to the edge. And actually, now that I think of this, we're just going to do this, we're going to say if the player dot rect dot right which will account for the width minus the offset x is greater than or equal to the width minus a variable that I'm going to write in a second, which is scroll area width and any Blair dot x underscore velocity is greater than zero. So if we're offsetting everything by 100 pixels, for example, I subtract that so I know where I'm actually showing the character on the screen and I say if that's greater than the width minus the scroll area width, which means I'm at say 700 pixels, something like that on the right side of the screen, then I'm going to offset the screen by whatever the velocity was that my player just moved to. And for this block, I'm going to place this at let's do zero. And then for the why, this is going to be the height of the screen minus the block size times two. So in our horizontal collision, we essentially need to check, okay, by moving in this direction, are you going to hit the block? If you are going to hit the block, we want to prevent you from moving in that direction so that you don't hit it, collide with it, and then we like spawn to the top of it. Again, the idea is we don't want to be thinking that we're hitting the block on the top when really we hit it on the left or the right side. So I'm going to make a function you say define collide mean it's a player objects a displacement X like that. So again, what I'm doing is I'm preemptively moving my player to where they would be moving if they're going left or right. I'm updating their mask and their rectangle and then I'm going to say for object in objects, if pie game dot, sprite dot collide mask and then I'm passing player and my object. So I'm going to say collide, underscore left is equal to collide player objects and then negative player. I collide with the object or not, because remember the sprites kind of shift to the left or to the right a little bit. So just by adding this multiplied by two, it should make it so that I'm never going to be colliding left or right. So for self fire, I'm going to use our load sprite sheets function for directory one. So Let's say ourself that image is going to be self. Okay, then I'm going to say self mask is equal to pi game masked from surface self-taught image like that. So I'm going to say my animation underscore count is equal to zero just like we did for our player. And I need to set myself dot animation underscore which for now is going to be equal to off. My first function is going to be on my first method and I can say self-taught animation name is equal to. And rather than self that sprite, we're going to change this to image. And with our player, we're constantly resetting the animation count when we jump or when we go left or when we go right. We just need to add a kind of state to our player to know if we're hit or not. But let's say f-pace multiplied by two, which is going to be 2 seconds, then the self taught hit is equal to false. Then we are going to say the sprite sheet is equal to hit. So I'm going to say to check is equal to collide left, collide right and asterisks vertical collide. And actually I'm going to say player to hits I want to call the method I don't want to set it equal to true. Okay, so let's go to player and let's go to hit count and let's make that equal to zero."
summary = "This game will have collisions, gravity, animated characters, and much much more!It will have all kinds of different animations for falling, jumping, colliding with obstacles.Now in this tutorial, you will learn how to use all of these characters and you can swap them out with a single line of code.Now really what I'm going to be showing you here mostly is sprite sheet animation, pixel perfect collision using what's called masks, and then how you can do the scrolling background generating objects, all of that kind of stuff.I quickly want to run through the assets folder and then we'll get into the code.For main characters, we have a bunch of sprite sheets inside of here and I'll show you how we can split these sprite sheets apart and use all of the different kind of animations inside of your right.I'll show you how we write a function that just loads these folders here, kind of splits the sprite sheets automatically and gives us all of the images that we're interested in.Next I'm going to say my focus, which is my frames per second, is going to be equal to 60 and I'm going to define my player velocity equal to five.If we run this file directly, if we don't run this file directly, say we imported something from it, then we won't run the game code.The event loop will be what's handling, say, the collision and moving our character, redrawing the window, all of that kind of stuff.What this line does is ensures that our while loop is going to run 60 frames per second.Then once we have the background, we can create a basic player that we can move around the screen.So I need to make a function here and I'm going to call this get underscore background.So the first thing we need to do here is load this background image.That's why this is going to work if you try to run this code from a different directory, says see the desktop and then I tried to run this, then I'm going to get an issue.And then what I'm going to do is join the assets path which is directly in the directory this files in with the background path here, if I spell background correctly and then with the name which is going to be the file name that I want to load, which is really just the color of the background.Height is equal to image.Then just to make sure that I don't have any gaps, I add one and I do the exact same thing for height in the y direction.So in case anyone's confused, what we're doing here is looping through every single tile that we have, and then we're going to draw our background image at that position, which will fill the entire screen with background images.Well, we probably want to put a player on the screen and start seeing some images for that player.So we'll start by just creating like a block for our player, kind of move the block around, have a jumping around.And the reason for that is that it makes it very easy to do pixel perfect collision when we have two sprite objects which we're going to have because we're inheriting from the pie game sprite class, we can use a method that tells us if the sprites are colliding with each other.But for now, since we're going to have like a block for our player, and so we add that image, we're going to have a width and height.And this is going to make it a little bit easier for us to kind of move the player around and do collision and all of that.Now this will be great, for example, for something like gravity or jumping, and you'll see what I mean in a minute.Next I'm going to say if self direction does not equal left, then self-taught direction is equal to left.And this is going to move our character in the correct direction and handle things like updating the animation and all of the stuff that we constantly need to do for our character.So now if we call loop and we have some velocity in the X direction is going to move our character to the left or to the right.Has our x y with height and when we move we're updating the x and y of the rectangle, which will then change where we're drawing it.We will add to this obviously in a second, but I think we can generate a player, draw the player, see it moving and then go from there.We can then take player inside of here and we can say, player don't draw and we can pass the window.Okay, so I will move the player in 1/2, but for now, let's just see if this is working, if it's going to show up on the screen.And then I'm going to say if this is the case, then player dots move underscore left and how much do I want to move the player likes we have to pass the velocity.Then I'm going to say player dots move underscore right again same thing I going to move this by my player velocity.We essentially set the velocity to zero and then if we are moving left or right, so for pressing these keys, then we change the velocity to be, you know, the negative player velocity or the positive player velocity based on the direction we're moving in.If you look at loop, it's moving my player in the x velocity and y velocity direction.But we kind of need collision before we can do jumping.And this is my fall count divided by the frames per second, multiplied by the self-taught gravity.Now that we have done that, it's time to move on and have some kind of sprites or images.She now this sheet has six different animations or six different frames which represent what this guy is going to look like while he's kind of jumping or double jumping in the air.So what we need to do is we need to split this one image into the six individual images and then loop through those images at some frequency or some time so that we can show them on the screen and show an animation.And the reason I'm doing this is so that I can load other images that aren't just my characters and this will be very dynamic.I also want to take in the desired width and height of my image and if we need to load multiple directions so I'm going to say direction equals false is the default parameters so that we only load like the left and the right side images like we flip the images if you passed this equal to true.So all sprites now I'm going to say for image in images and I'm going to say that my sprite sheet, so the individual sprite sheet I want to load here is going to be equal to pie game dot image default load and then this is going to be join path and image and then dot convert alpha, which is essentially going to allow me to load a transparent background image.Now we need to get all the individual images from the spreadsheet and load those, get some going, say for I in range and then this is going to be sprite sheet get underscore width integer divided by the width of the image that we're loading now.But this just what we need to load these images and now we need to create a rectangle which is going to tell us where in this image, an image being the sprite sheet that we want to take, an individual image from and bullet it onto the surface.So we're going to say, okay, all sprites at and then we're just going to strip off the dot page from whatever the name of our base image was that's going to give us run, jump, idle, hit whatever the name of our files and then we're going to spend on her school right or underscore left now for underscore right, that's our basic sprites for underscore left.So make sure you do this 30 to 32 and then you pass through because we want a sprite.Then I'll go through animating the Sprite and showing you how that works.So I'm going to write a function here called Update Sprite, and I'm going to take itself and I'm going to say Sprite sheet is equal to idle.So now I'm going to say if my self-taught x velocity does not equal zero, then my sprite sheet is going to be equal to run.So now we just change the main sprite sheet name so it'll run, jump, whatever, we add the direction to it.So hopefully you guys understand how this animation count is kind of working.Now what we can do is remove this here from draw and we just need to now call the self dot update sprite from our loop.So now that we've done that, we'll call this, we'll update our Sprite every single frame and then we'll draw that updated sprite on the screen.So it's different like kind of sizes to the sprites, right?Again, I know this seems a bit weird, but we're going to do this are going to say self direct is equal to self dot and then it's going to be sprite get underscore rect.And this mask allows us to perform pixel perfect collision because we can overlap it with another mask and make sure that we only say two objects collide if pixels are colliding, not if the rectangular box is colliding.So what we want to do now is we want to start adding blocks onto the screen and then letting a player fall, collide with those blocks and then be able to jump.So we have a rectangle, we have our image, we are drawing the image and then in a class.Then we're going to say block is equal to load block, which is going be a function that we write in a second that will take a size.We also could just say self that image is equal to the block, but let's do it this way for now.Now that we have done that, now that we have our path, we're going to say the image is equal to py game dot image, dot load and we're going to say path again to convert alpha so that we get a transparent background.But I just want you to understand that what I'm passing here, when I say something like 96 zero, I'm passing the position that I want to load the image from from the image, right?And if yeah, I was going to say we can load different one, but I don't want to waste time guessing which one it is.That's what you're going to change when you want to load a different image for your block.Let's draw a block on the screen and let's do some collision with our blocks.So let's go here to Main and let's say blocks is equal to and let's just start by creating a single block.Let's put this at zero height minus the block underscore size.So we're going to create a block that's going to be positioned at zero height, minus block size, which is going to put it at the bottom of the screen.So now what we can do is create a whole floor of blocks if we want to do that and then we'll implement gravity and then collision with the blocks so that you can see that you can land on the block and we can jump off of the block.Then for my blocks, let's actually just replace this and instead we'll just pass for okay, what I've done here with this for loop is I've said I want to create blocks that go kind of to the left and to the right of the screen.Anyways, I want to have some kind of go into the left and some going to the right.So I'm taking my negative with over the block size, which is how many blocks I want to the left side of the screen.I'm going to say if my game dot sprites, dot collide mask and then we're going to pass our player and our object.Now, what this is saying is if I'm moving down on the screen, so if I'm moving down, then that would mean I was colliding with the top of this object.And I'm going to make it equal the top of the object.Now, one thing we also need to do here is need to call the method player down landed and player dot hit head, which I've not yet created.And we're going to write these to handle what happens when we land on a block and when we hit our head on a block.We'll hit the block, we'll move us to the top of the block, and then we should just build a move on top of the block.Although it's not going to work if we don't add the function call.So let's add the function call here in handle move.And boom, look, we land on a block and we can now run on top of the block and everything is looking very good to me.Now that we're on top of a block, we can jump and then we can deal with hitting blocks.So that we can't, like, run into a block and we'll also make the background scroll and then we'll be pretty good.So if the jump counts equal to one when I hit jump, that means it's just going to be equal to two.Okay, so what I'm trying to do here is make it so that as soon as I jump, I essentially get rid of any gravity I've already obtained.So when we hit space, we jump so we can do that inside of handle move.And the reason for this is that if I do it in handle move, what's going to happen is if I press the jump key and I hold the jump key down, I'm going to keep jumping a bunch of times.Okay, underscore space and my player dot jump count is less than two.So let's try it out and let's see if this works and I can jump and notice I can kind of run and jump at the same time.Now what I'll do now is add like falling and jumping animations because obviously it looks kind of weird right now when I'm jumping, but there you go.I thought, I mean to say if not self if self doubt y underscore velocity does not equal zero, then what I will do is say if self-taught jump count equals equals one, then I'm going to say my sprite sheet is equal to jump.I'm going to say self, self don't jump count equals equals to.So let me show you what I mean by just kind of running the code here.So You can see that what happens is when I hit the block, when I collide with it, it's going to reset my gravity count and then I'm going to kind of spawn to the top of the block.And you can see that what actually happened is when I jump and I get to the peak of my jump, you can see that it starts the falling state because right now my velocity is change directions.Okay, so now we have jumping, now we have running around and colliding with blocks then quite a bit actually.The next thing I want to do is make it so that objects move on the screen.Then we will do our horizontal collision and then we will pretty much be done after I add kind of that like fire state, right?So any object that we have, we don't change its position at all.We just change how we're drawing it on the screen so it doesn't affect any of our collision.And actually, now that I think of this, we're just going to do this, we're going to say if the player dot rect dot right which will account for the width minus the offset x is greater than or equal to the width minus a variable that I'm going to write in a second, which is scroll area width and any Blair dot x underscore velocity is greater than zero.So if we're offsetting everything by 100 pixels, for example, I subtract that so I know where I'm actually showing the character on the screen and I say if that's greater than the width minus the scroll area width, which means I'm at say 700 pixels, something like that on the right side of the screen, then I'm going to offset the screen by whatever the velocity was that my player just moved to.And then for the why, this is going to be the height of the screen minus the block size times two.So just see, now I want to go and rather than drawing my floor, I want to pass objects and same here with handle move on to pass objects.Notice that when I hit the block, I kind of go to the top of it.So we need to make it now so that when you hit the block in the horizontal direction, it kind of pops you off of it so that it doesn't think you're hitting the top of the block or the bottom of the block, alternatively, which you'll see in a second.The idea behind this is that since we're using our Sprite Collide mask, we want to make sure that if we collide with a block horizontally, we move ourselves off of that block so that it doesn't think that we're colliding with it in the vertical direction.So in our horizontal collision, we essentially need to check, okay, by moving in this direction, are you going to hit the block?If you are going to hit the block, we want to prevent you from moving in that direction so that you don't hit it, collide with it, and then we like spawn to the top of it.Again, the idea is we don't want to be thinking that we're hitting the block on the top when really we hit it on the left or the right side.So I'm going to make a function you say define collide mean it's a player objects a displacement X like that.The reason I'm doing this is I want to check if with the current velocity that my player has, if now the reason I'm doing this is I want to check if my player were to move to the right or if they were to move to the left, would they hit a block?I'm updating their mask and their rectangle and then I'm going to say for object in objects, if pie game dot, sprite dot collide mask and then I'm passing player and my object.So I move my player, I update it and then using that updated mask, I check what I be colliding with an object.Okay, then I'm going to say, player, don't move and I'm going to move them back and then I'm going to say player dot update.So what I'm doing right, I'm moving my player, I'm updating the mask, I'm checking if they would with something.So I'm going to say collide, underscore left is equal to collide player objects and then negative player.And then here I only let you make the movement if that movement does not cause you moving into a block or colliding with one, now that we have that, that should actually handle our horizontal collision, that's actually all we need.So that time it worked, but it's a little bit glitchy and I have a feeling it has to do with the animation count of me running because it's only some times when I'm running and I hit the block that it spawns me up here.So now we have collision with blocks, we have a scrolling background, we have double jumping.So for self fire, I'm going to use our load sprite sheets function for directory one.I'm again going to have my animation delay, so let's make that equal three and now let's specify our image.So I'm going to say my animation underscore count is equal to zero just like we did for our player.And I need to set myself dot animation underscore which for now is going to be equal to off.And rather than self that sprite, we're going to change this to image.We're going to get rid of this sprite sheet name and rather than Sprite sheet name, we're going to say it's self dot animation name.My image is equal to sprites at sprite index and then I increment the animation count, update my rectangle and update my mask, which is important for the collision.And with our player, we're constantly resetting the animation count when we jump or when we go left or when we go right.So you go to fire and what do we need to pass for fire in x, y, width and height so we can pick where we want to put this?Okay, that's what the size is and you need to pass that correctly to the fire class, otherwise it won't load the image properly.So we take our height minus our block size, -64, which will put us on top of a block.But however it is off now the reason it's off is because we didn't call the loop method on fire.Now let's call it and it should start being on fire object has not shoot sprites.And notice that I can kind of be on top of the fire, right?And it's like pixel perfect collision pretty much when I'm hitting it.We just need to add a kind of state to our player to know if we're hit or not.Then we're going to go in loop and before our update sprite, we're going to say if self-taught hit, then self-taught hit count plus equals one.Then we are going to say the sprite sheet is equal to hit.Now, what we're going to do is we're essentially going to loop through all of these objects and we're going to see if we hit fire.Remember I'm going to say if to underscore, check and to underscore check dot name is equal to fire then player dot hit is able to trip.And actually I'm going to say player to hits I want to call the method I don't want to set it equal to true.So what we're doing here is looking through all the objects we collide with, if any of them are fire, then we will put hit on the player.So I need to make sure I handle that case before I try to access name on an object that isn't defined.Okay, so let's go to player and let's go to hit count and let's make that equal to zero.Let's scroll down, keep scrolling with our so we have to check if okay you would be a name equals it goes fire player don't make hit okay I'm not sure what the bug is.This showed you how to create a platformer, how to do animations, how to be sprites, how to do a scrolling background."
ROUGE = Rouge()
print(ROUGE.get_scores(summary,reference))
